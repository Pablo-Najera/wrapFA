#' Bayesian structural equation modeling (BSEM)
#'
#' @description Fit a BSEM (BSEM; Muthén & Asparouhov, 2012) via \emph{MplusAutomation}.
#'
#' @param model A \code{list} containing two \code{character} elements: the user-specified BSEM model and the priors specification using the \emph{Mplus} syntax .
#' @param data A \emph{N} individuals x \emph{J} observed variables \code{matrix} or \code{data.frame}. Missing values need to be coded as \code{NA}.
#' @param categorical A \code{vector} containing the number or name of the observed variables that need to be treated as categorical. Default is \code{NULL}, which treates all observed variables as continuous.
#' @param mplus.path A \code{character} indicating the path where the the files generated by \emph{Mplus} will be stored, including the name of the files. Default is \code{NULL}, which stores the files in the current working directory with the name \emph{wrapBSEM}.
#' @param rm.files A \code{logical} indicating whether the stored files should be deleted. The default is \code{FALSE}.
#' @param max.iter A \code{double} indicating the maximum number of iterations. Default is 60000.
#' @param n.cores A \code{double} indicating the number of CPU processors to be used for the estimation of the model. Default is 1.
#' @param n.chains A \code{double} indicating the number of MCMC chains. Default is 2.
#' @param suppressMessages A \code{logical} indicating whether the messages from MplusAutomation should be silent. Default is \code{TRUE}.
#'
#' @return \code{BSEM} returns an object of class \code{wrapFA}.
#' \describe{
#' \item{\code{model.fit}}{Model fit indices (\code{vector}).}
#' \item{\code{lambda}}{The standardized estimated factor loading matrix (\code{matrix}).}
#' \item{\code{phi}}{The standardized estimated factor correlation matrix (\code{matrix}).}
#' \item{\code{psi}}{The standardized estimated error correlation matrix (\code{matrix}).}
#' \item{\code{lambda.p}}{The p-value associated to each free parameter in the estimated factor loading matrix (\code{matrix}).}
#' \item{\code{phi.p}}{The p-value associated to each free parameter in the estimated factor correlation matrix (\code{matrix}).}
#' \item{\code{psi.p}}{The p-value associated to each free parameter in the estimated error correlation matrix (\code{matrix}).}
#' \item{\code{out}}{The complete output provided by \emph{Mplus} (\code{list}).}
#' \item{\code{specifications}}{Specifications used to run the function (\code{list}).}
#' }
#'
#' @references
#' Muthén, B. & Asparouhov, T. (2012). Bayesian structural equation modeling: A more flexible representation of substantive theory. \emph{Psychological Methods}, \emph{17}, 313-335. https://doi.org/10.1037/a0026802
#'
#' @export
#'
#' @examples
#' \dontrun{
#' BFI <- psych::bfi
#' BFI <- BFI[,1:25]
#' modBFI <- data.frame(agree = c(rep(1, 5), rep(0, 20)),
#'                        consc = c(rep(0, 5), rep(1, 5), rep(0, 15)),
#'                        extra = c(rep(0, 10), rep(1, 5), rep(0, 10)),
#'                        neuro = c(rep(0, 15), rep(1, 5), rep(0, 5)),
#'                        openn = c(rep(0, 20), rep(1, 5)), row.names = colnames(BFI))
#' modBFI.mpl <- modFA(lambda = modBFI, software = "mplus", keep.names = TRUE)
#' bsem <- BSEM(model = modBFI.mpl$BSEM, data = BFI, categorical = 1:25, n.cores = 2)
#' }
BSEM <- function(model, data, categorical = NULL, mplus.path = NULL, rm.files = FALSE, max.iter = 60000, n.cores = 1, n.chains = 2, suppressMessages = TRUE){

  #--------------------
  # 1. Check arguments
  #--------------------

  if(!is.list(model)){
    stop("model must be a list contaning the model specification and the priors specification.")
  } else {
    if(!grepl("BY", model[[1]])){stop("model must be specified in Mplus syntax.")}
  }
  if(is.matrix(data)){
    data <- as.data.frame(data)
    if(all(colnames(data) == paste0("V", 1:ncol(data)))){colnames(data) <- paste0("x", 1:ncol(data))}
  } else if(!is.data.frame(data)){
    stop("data must be either a matrix or data.frame.")
  }
  if(!is.null(categorical)){
    if(is.numeric(categorical)){
      categorical <- colnames(data)[categorical]
    } else if (is.character(categorical)){
      if(!all(categorical %in% colnames(data))){stop("categorical contains some observed variables that are not detected in data.")}
    } else {
      stop("categorical must be either a numerical or character vector.")
    }
  }
  if(!is.numeric(max.iter)){stop("max.iter must be numeric.")}
  if(!is.numeric(n.cores)){stop("n.cores must be numeric.")}
  if(!is.numeric(n.chains)){stop("n.chains must be numeric.")}
  if(is.null(mplus.path)){
    mplus.path <- "wrapBSEM"
  } else {
    if(!is.character(mplus.path)){stop("mplus.path must be of type character.")}
  }

  namesF <- strsplit(model$model, ";\n")[[1]]
  namesF <- namesX <- namesF[!grepl(" WITH ", namesF)]
  namesF <- unique(gsub(" ", "", sapply(strsplit(namesF, " BY "), function(x) x[1])))
  nF <- length(namesF)
  namesX <- gsub(";", "", unique(unlist(strsplit(sapply(strsplit(namesX, " BY "), function(x) x[2]), " "))))
  namesX <- namesX[!grepl("-", namesX)]
  nX <- length(namesX)

  #---------------
  # 2. mplus BSEM
  #---------------

  # 2.1. Fit BSEM model
  if(!is.null(categorical)){
    mplus.VARIABLE <- paste0("CATEGORICAL = ", paste(categorical, collapse = " "), ";")
    if(nchar(mplus.VARIABLE) >= 90){
      cut <- 1
      tmp <- c()
      for(s in 1:(ceiling((nchar(mplus.VARIABLE) + 1) / 90))){
        pos <- which.min(abs(gregexpr(" ", mplus.VARIABLE)[[1]] - round(nchar(mplus.VARIABLE) / ceiling((nchar(mplus.VARIABLE) + 1) / 90)) * s))
        cut <- c(cut, gregexpr(" ", mplus.VARIABLE)[[1]][pos])
        if(s == 1){
          tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s], cut[s + 1] - 1), "\n"))
        } else if(s > 1 & s < ceiling((nchar(mplus.VARIABLE) + 1) / 90)) {
          tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s] + 1, cut[s + 1] - 1), "\n"))
        } else {
          tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s] + 1, nchar(mplus.VARIABLE))))
        }
      }
      mplus.VARIABLE <- paste(tmp, collapse = "")
    }
  } else {
    mplus.VARIABLE <- NULL
  }
  mplus.MODEL <- model[[1]]
  mplus.PRIORS <- model[[2]]
  mplus.ANALYSIS <- paste0("ESTIMATOR = BAYES; PROCESSORS = ", n.cores,"; CHAINS = ", n.chains, "; BITERATIONS = ", max.iter, ";")
  mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = mplus.MODEL, ANALYSIS = mplus.ANALYSIS, MODELPRIORS = mplus.PRIORS, OUTPUT = "STANDARDIZED")
  if(suppressMessages){
    BSEM <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
  } else {
    BSEM <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
  }
  if(length(BSEM$results$warnings) > 0){print(BSEM$results$warnings)}
  if(length(BSEM$results$errors) > 0){
    if(!grepl("FBITERATIONS", BSEM$results$errors)){
      print(BSEM$results$errors); stop("Mplus had convergence problems.")
    }
  }

  # 2.2. Gather results
  fit <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "summaries", quiet = TRUE)$summaries
  coef <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "parameters", quiet = TRUE)$parameters$stdyx.standardized
  if(is.null(coef)){stop("Mplus had convergence problems.")}
  lambda <- matrix(0, nrow = nX, ncol = nF, dimnames = list(namesX, namesF))
  lambda.p <- matrix(NA, nrow = nX, ncol = nF, dimnames = list(namesX, namesF))
  phi <- matrix(0, nrow = nF, ncol = nF, dimnames = list(namesF, namesF))
  phi.p <- matrix(NA, nrow = nF, ncol = nF, dimnames = list(namesF, namesF))
  psi <- matrix(0, nrow = nX, ncol = nX, dimnames = list(namesX, namesX))
  psi.p <- matrix(NA, nrow = nX, ncol = nX, dimnames = list(namesX, namesX))
  tmp.lambda <- coef[grepl(".BY", coef$paramHeader),]
  tmp.lambda$paramHeader <- sapply(tmp.lambda$paramHeader, function(x) strsplit(x, "\\.")[[1]][1])
  tmp.phi <- coef[grepl(".WITH", coef$paramHeader) & coef$param %in% namesF,]
  tmp.phi$paramHeader <- sapply(tmp.phi$paramHeader, function(x) strsplit(x, "\\.")[[1]][1])
  tmp.phi <- tmp.phi[tmp.phi$paramHeader %in% namesF,]
  tmp.phi <- rbind(tmp.phi, coef[coef$paramHeader == "Variances",])
  tmp.psi <- coef[grepl(".WITH", coef$paramHeader) & coef$param %in% namesX,]
  tmp.psi$paramHeader <- sapply(tmp.psi$paramHeader, function(x) strsplit(x, "\\.")[[1]][1])
  tmp.psi <- tmp.psi[tmp.psi$paramHeader %in% namesX,]
  tmp.psi <- rbind(tmp.psi, coef[coef$paramHeader == "Residual.Variances",])
  for(x in 1:nrow(tmp.lambda)){
    lambda[tmp.lambda$param[x], tmp.lambda$paramHeader[x]] <- tmp.lambda$est[x]
    lambda.p[tmp.lambda$param[x], tmp.lambda$paramHeader[x]] <- tmp.lambda$pval[x]
  }
  for(f in 1:nrow(tmp.phi)){
    if(tmp.phi$paramHeader[f] != "Variances"){
      phi[tmp.phi$param[f], tmp.phi$paramHeader[f]] <- round(tmp.phi$est[f], 5)
      phi[tmp.phi$paramHeader[f], tmp.phi$param[f]] <- round(tmp.phi$est[f], 5)
      phi.p[tmp.phi$param[f], tmp.phi$paramHeader[f]] <- round(tmp.phi$pval[f], 5)
      phi.p[tmp.phi$paramHeader[f], tmp.phi$param[f]] <- round(tmp.phi$pval[f], 5)
    } else {
      phi[tmp.phi$param[f], tmp.phi$param[f]] <- round(tmp.phi$est[f], 5)
      phi.p[tmp.phi$param[f], tmp.phi$param[f]] <- NA
    }
  }
  if(nrow(tmp.psi) > 0){
    for(x in 1:nrow(tmp.psi)){
      if(tmp.psi$paramHeader[x] != "Residual.Variances"){
        psi[tmp.psi$param[x], tmp.psi$paramHeader[x]] <- round(tmp.psi$est[x], 5)
        psi[tmp.psi$paramHeader[x], tmp.psi$param[x]] <- round(tmp.psi$est[x], 5)
        psi.p[tmp.psi$param[x], tmp.psi$paramHeader[x]] <- round(tmp.psi$pval[x], 5)
        psi.p[tmp.psi$paramHeader[x], tmp.psi$param[x]] <- round(tmp.psi$pval[x], 5)
      } else {
        psi[tmp.psi$param[x], tmp.psi$param[x]] <- round(tmp.psi$est[x], 5)
        psi.p[tmp.psi$param[x], tmp.psi$param[x]] <- NA
      }
    }
  }

  if(all(psi == 0)){
    hj <- diag((lambda %*% phi) %*% solve(phi) %*% t(lambda %*% phi))
    diag(psi) <- 1 - hj
  }

  if(is.null(categorical)){
    fit <- round(c(npar = as.numeric(fit["Parameters"]), PostPredictive_p = as.numeric(fit["PostPred_PValue"]),
                   BIC = as.numeric(fit["BIC"]), DIC = as.numeric(fit["DIC"])), 3)
  } else {
    fit <- round(c(npar = as.numeric(fit["Parameters"]), PostPredictive_p = as.numeric(fit["PostPred_PValue"])), 3)
  }

  #-------------------
  # 3. Export results
  #-------------------

  if(rm.files){file.remove(paste0(mplus.path, c(".dat", ".inp", ".out")))}
  specifications <- list(type = "BSEM", model = model, data = data, categorical = categorical, estimator = "Bayes", software = "mplus", mplus.path = mplus.path, rm.files = rm.files, max.iter = max.iter, n.cores = n.cores, n.chains = n.chains)
  res <- list(model.fit = fit, lambda = lambda, phi = phi, psi = psi, lambda.p = lambda.p, phi.p = phi.p, psi.p = psi.p, out = BSEM, specifications = specifications)
  class(res) <- "wrapFA"
  return(res)

}
