#' Exploratory factor analysis (EFA)
#'
#' @description Fit an EFA model via \emph{lavaan} or \emph{MplusAutomation}. Correlated residuals can be included in the
#' model as in exploratory structural equation modeling (ESEM; Asparouhov & Muthén, 2009). Several rotation procedures are supported. The objectively
#' refined target matrix (RETAM) procedure (Lorenzo-Seva & Ferrando, 2020) is also available if \emph{MplusAutomation} is used. Moreover, sequential
#' model modifications can be implemented by using modification indices (MI) or the procedure proposed by Saris et al. (2009).
#'
#' @param model A \code{character} string containing the EFA model using either the \emph{lavaan} or \emph{Mplus} syntax. It can be null if the number of factors is specified instead in the argument \code{n.factors}.
#' @param data A \emph{N} individuals x \emph{J} observed variables \code{matrix} or \code{data.frame}. Missing values need to be coded as \code{NA}.
#' @param n.factors A \code{double} indicating the number of factors to extract. It can be null if \code{model} is specified instead.
#' @param categorical A \code{vector} containing the number or name of the observed variables that need to be treated as categorical. Default is \code{NULL}, which treates all observed variables as continuous.
#' @param estimator A \code{character} indicating the estimator to be used to fit the model. It can be \code{"ML"}, \code{"MLM"}, \code{"MLMV"}, \code{"MLMVS"}, \code{"MLF"}, \code{"MLR"}, \code{"GLS"}, \code{"DWLS"}, \code{"WLS"}, \code{"WLSM"}, \code{"WLSMV"}, \code{"ULS"},\code{"ULSM"}, and \code{"ULSMV"}. Check \code{?lavaan::lavOptions} or the \emph{Mplus} User's Guide for more information. Default is \code{NULL}, which uses \code{"ML"} if all observed variables are continuous and \code{"WLSMV"} if any observed variable is categorical.
#' @param rotation A \code{character} indicating the rotation procedure to be used. It can be \code{"Geomin"}, \code{"Target"}, \code{"RETAM"}, \code{"Oblimin"}, \code{"Promax"}, \code{"Varimax"}, and \code{"Quartimin"}. \code{"Target"} and \code{"RETAM"} are only available for \emph{Mplus}.
#' @param software A \code{character} indicating the software to use for fitting the EFA model. It can be \code{"lavaan"} or \code{"mplus"}. Only required if design matrices are used in the \code{model} argument; the software is automatically detected if a syntax is used. Default is \code{NULL}.
#' @param mimic.mplus A \code{logical} indicating whether \emph{lavaan} should mimic \emph{Mplus} output. Only applicable to \emph{lavaan}. Default is \code{TRUE}.
#' @param mplus.path A \code{character} indicating the path where the the files generated by \emph{Mplus} will be stored, including the name of the files. Default is \code{NULL}, which stores the files in the current working directory with the name \emph{wrapEFA}.
#' @param rm.files A \code{logical} indicating whether the stored files should be deleted. The default is \code{FALSE}.
#' @param max.iter A \code{double} indicating the maximum number of iterations. Default is 10000.
#' @param mod A \code{character} indicating whether sequential model modifications are permitted. It can be \code{"none"} for no modifications, \code{"MI"} for modifications based solely on modification indices, or \code{"Saris"} for the Saris procedure (Saris et al., 2009). \code{"Saris"} is only applicable to \emph{lavaan}. Default is \code{"none"}.
#' @param mod.args A \code{list} of arguments for specifying the sequential model modification search:
#' \describe{
#' \item{\code{stepwise}}{A \code{logical} indicating whether model modifications should be included sequentially (rather than in a single step). Default is \code{TRUE}.}
#' \item{\code{mod.error}}{A \code{logical} indicating whether error correlations should be permitted. Default is \code{TRUE}.}
#' \item{\code{MI.cut}}{A \code{numeric} indicating the MI cutoff point. Default is \code{3.841459}.}
#' \item{\code{MI.power}}{A \code{numeric} indicating the cutoff for the power associated to the MI in the Saris procedure. Default is 0.75.}
#' \item{\code{SEPC.lambda}}{A \code{numeric} indicating the cutoff for the standardized expected parameter change (SEPC) associated to factor loadings in the Saris procedure. Default is 0.4.}
#' \item{\code{SEPC.psi}}{A \code{numeric} indicating the cutoff for the SEPC associated to error correlations in the Saris procedure. Default is 0.1.}
#' \item{\code{max.mods}}{A \code{double} indicating the maximum number of modifications permitted. Default is 50.}
#' }
#' @param suppressMessages A \code{logical} indicating whether the messages from MplusAutomation should be silent. Default is \code{TRUE}.
#'
#' @return \code{EFA} returns an object of class \code{wrapFA}.
#' \describe{
#' \item{\code{model.fit}}{Model fit indices (\code{vector}).}
#' \item{\code{lambda}}{The standardized estimated factor loading matrix (\code{matrix}).}
#' \item{\code{phi}}{The standardized estimated factor correlation matrix (\code{matrix}).}
#' \item{\code{psi}}{The standardized estimated error correlation matrix (\code{matrix}).}
#' \item{\code{lambda.p}}{The p-value associated to each free parameter in the estimated factor loading matrix (\code{matrix}).}
#' \item{\code{phi.p}}{The p-value associated to each free parameter in the estimated factor correlation matrix (\code{matrix}).}
#' \item{\code{psi.p}}{The p-value associated to each free parameter in the estimated error correlation matrix (\code{matrix}).}
#' \item{\code{MI}}{Information about the MI and SEPC of the fixed parameters (\code{matrix}).}
#' \item{\code{mods}}{The modifications included in the model (\code{matrix}).}
#' \item{\code{out}}{The complete output provided by either \emph{lavaan} or \emph{Mplus} (\code{list}).}
#' \item{\code{specifications}}{Specifications used to run the function (\code{list}).}
#' }
#'
#' @references
#' Asparouhov, T., & Muthén, B. O. (2009). Exploratory structural equation modeling. \emph{Structural Equation Modeling: A Multidisciplinary Journal}, \emph{16}(3), 397-438. https://doi.org/10.1080/10705510903008204
#' Lorenzo-Seva, U., & Ferrando, P. J. (2020). Unrestricted factor analysis of multidimensional test items based on an objectively refined target matrix. \emph{Behavior Research Methods}, \emph{52}, 116-130. https://doi.org/10.3758/s13428-019-01209-1
#' Saris, W. E., Satorra, A., & van der Veld, W. M. (2009). Testing structural equation models or detection of misspecifications?. \emph{Structural Equation Modeling}, \emph{16}, 561-582. https://doi.org/10.1080/10705510903203433
#'
#' @export
#'
#' @examples
#' \dontrun{
#' library(MBESS)
#' data(HS)
#' HS <- HS[, -c(1:8)]
#' colnames(HS) <- paste0("t", 1:26)
#' modHS <- data.frame(spatial = c(rep(1, 4), rep(0, 20), rep(1, 2)),
#'                     verbal = c(rep(0, 4), rep(1, 5), rep(0, 17)),
#'                     speed = c(rep(0, 9), rep(1, 4), rep(0, 13)),
#'                     memory = c(rep(0, 13), rep(1, 6), rep(0, 7)),
#'                     maths = c(rep(0, 19), rep(1, 5), rep(0, 2)), row.names = colnames(HS))
#' modHS.lav <- modFA(lambda = modHS, software = "lavaan", keep.names = TRUE)
#' modHS.mpl <- modFA(lambda = modHS, software = "mplus", keep.names = TRUE)
#' efa_geomin <- EFA(model = modHS.lav$EFA, data = HS)
#' efa_target <- EFA(model = modHS.mpl$EFAt, data = HS, rotation = "TARGET")
#' }
EFA <- function(model = NULL, data, n.factors = NULL, categorical = NULL, estimator = NULL, rotation = "Geomin", software = NULL, mimic.mplus = TRUE, mplus.path = NULL, rm.files = FALSE, max.iter = 10000,
                mod = "none", mod.args = list(stepwise = TRUE, mod.error = TRUE, MI.cut = 3.841459, MI.power = 0.75, SEPC.lambda = 0.4, SEPC.psi = 0.1, max.mods = 50), suppressMessages = TRUE){

  #--------------------
  # 1. Check arguments
  #--------------------

  if(is.null(model) & is.null(n.factors)){stop("Either model or n.factors must be provided.")}
  if(is.null(model)){
    if(is.null(software)){stop("software must be specified if model is not provided.")}
    tmp <- matrix(1, nrow = ncol(data), ncol = n.factors, dimnames = list(colnames(data), paste0("F", 1:n.factors)))
    model <- modFA(tmp, software = software)$EFA
  }
  if(is.character(model)){
    if(grepl("BY", model)){
      software <- "mplus"
    } else if(grepl("=~", model)){
      software <- "lavaan"
    }
  } else if(is.list(model)){
    if(length(model) != 3){stop("model does not contain the three required design matrices (Lambda, Phi, and Psi).")}
    if(is.null(software)){stop("software must be specified if design matrices are used to specify model.")}
    if(!software %in% c("mplus", "lavaan")){stop("software must be 'mplus' or 'lavaan'.")}
    lambdaD <- model[[1]]
    phiD <- model[[2]]
    psiD <- model[[3]]
    model <- modFA(lambda = lambdaD, phi = phiD, psi = psiD, software = software)$EFA
    latvar.names <- rownames(phiD)
  } else {
    stop("model must be specified either by an Mplus or lavaan syntax, or a list containing the three design matrices (Lambda, Phi, and Psi).")
  }
  if(software == "lavaan"){
    rotation <- tolower(rotation)
    if(!rotation %in% c("oblimin", "quartimin", "pst", "oblimax", "entropy", "quartimax", "varimax", "simplimax", "bentler", "tandemI", "tandemII", "geomin", "cf", "infomax", "mccammon")){
      stop("lavaan supports the following rotation methods: 'oblimin', 'quartimin', 'pst', 'oblimax, 'entropy', 'quartimax', 'varimax', 'simplimax', 'bentler', 'tandemI', 'tandemII', 'geomin', 'cf', 'infomax', 'mccammon'.")
    }
  } else if(software == "mplus"){
    rotation <- toupper(rotation)
    if(!rotation %in% c("GEOMIN", "QUARTIMIN", "CF-VARIMAX", "CF-QUARTIMAX", "CF-EQUAMAX", "CF-PARSIMAX", "CF-FACPARSIM", "CRAWFER", "OBLIMIN", "VARIMAX", "PROMAX", "TARGET", "RETAM", "BI-GEOMIN", "BI-CF-QUARTIMAX")){
      stop("Mplus supports the following rotation methods: 'GEOMIN', 'QUARTIMIN', 'CF-VARIMAX', 'CF-QUARTIMAX', 'CF-EQUAMAX', 'CF-PARSIMAX', 'CF-FACPARSIM', 'CRAWFER', 'OBLIMIN', 'VARIMAX', 'PROMAX', 'TARGET', 'RETAM', 'BI-GEOMIN', 'BI-CF-QUARTIMAX'.")
    }
  }
  if(is.matrix(data)){
    data <- as.data.frame(data)
    if(all(colnames(data) == paste0("V", 1:ncol(data)))){colnames(data) <- paste0("x", 1:ncol(data))}
  } else if(!is.data.frame(data)){
    stop("data must be either a matrix or data.frame.")
  }
  if(is.null(categorical)){
    if(is.null(estimator)){estimator <- "ML"}
  } else {
    if(is.null(estimator)){estimator <- "WLSMV"}
    if(is.numeric(categorical)){
      categorical <- colnames(data)[categorical]
    } else if (is.character(categorical)){
      if(!all(categorical %in% colnames(data))){stop("categorical contains some observed variables that are not detected in data.")}
    } else {
      stop("categorical must be either a numerical or character vector.")
    }
  }
  if(!estimator %in% c("ML", "MLM", "MLMV", "MLMVS", "MLF", "MLR", "GLS", "DWLS", "WLS", "WLSM", "WLSMV", "ULS","ULSM", "ULSMV")){stop("estimator is not recognized.")}
  if(!mod %in% c("none", "Saris", "MI")){stop("mod must be 'none', 'MI', or 'Saris'.")}
  if(mod == "Saris" & software == "mplus"){
    warning("The Saris procedure is not compatible with Mplus. MI will be used instead.")
    mod <- "MI"
  }
  if(mod != "none" & rotation == "RETAM"){
    warning("No sequential modifications will be introduced when using the RETAM procedure.")
    mod <- "none"
  }
  if(is.null(mod.args$stepwise)){mod.args$stepwise <- TRUE}
  if(is.null(mod.args$mod.error)){mod.args$mod.error <- TRUE}
  if(is.null(mod.args$MI.cut)){mod.args$MI.cut <- 3.841459}
  if(is.null(mod.args$MI.power)){mod.args$MI.power <- .75}
  if(is.null(mod.args$SEPC.lambda)){mod.args$SEPC.lambda <- .4}
  if(is.null(mod.args$SEPC.psi)){mod.args$SEPC.psi <- .1}
  if(is.null(mod.args$max.mods)){mod.args$max.mods <- 50}
  if(!is.numeric(max.iter)){stop("{max.iter} must be numeric.")}
  if(is.null(mplus.path)){
    mplus.path <- "wrapEFA"
  } else {
    if(!is.character(mplus.path)){stop("mplus.path must be of type character.")}
  }
  if(mimic.mplus){
    mimic <- "Mplus"
  } else {
    mimic <- "lavaan"
  }
  mods <- NULL

  #---------------
  # 2. lavaan EFA
  #---------------

  if(software == "lavaan"){

    # 2.1. Fit EFA model and compute MI
    EFA <- EFA.back <- lavaan::lavaan(model, data, ordered = categorical, estimator = estimator, rotation = rotation, auto.var = TRUE, auto.efa = TRUE, int.ov.free = TRUE, mimic = mimic, control = list(iter.max = max.iter))
    if(!lavaan::lavInspect(EFA, what = "converged")){stop("The EFA model has not converged.")}
    MI <- lavaan::modindices(EFA, standardized = TRUE, power = TRUE, sort. = TRUE)
    phi <- as.matrix(as.data.frame(lavaan::inspect(EFA, what = "std")$psi))
    namesF <- colnames(phi)
    check.MI <- MI[MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF,]
    rm.MI <- apply(check.MI, 1, function(mi) phi[mi["lhs"], mi["rhs"]] != 0)
    if(length(which(MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF)[rm.MI]) > 0){
      MI <- MI[-which(MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF)[rm.MI],]
    }

    # 2.2. Introduce modifications if required
    if(mod != "none"){
      do.MI <- MI[MI$mi >= mod.args$MI.cut,]
      if(mod == "Saris"){
        tmp.do.MI <- do.MI[do.MI$op == "=~" & (abs(do.MI$sepc.all) >= mod.args$SEPC.lambda | do.MI$power < mod.args$MI.power),]
        tmp.do.MI <- rbind(tmp.do.MI, do.MI[do.MI$op == "~~" & (abs(do.MI$sepc.all) >= mod.args$SEPC.psi | do.MI$power < mod.args$MI.power),])
        do.MI <- tmp.do.MI
      }
      if(!mod.args$mod.error){do.MI <- do.MI[do.MI$op == "=~",]}
      if(nrow(do.MI > 0)){
        if(!mod.args$stepwise){
          mods <- do.MI
          model <- paste(model, paste(apply(mods[,1:3], 1, paste, collapse = " "), collapse = "\n"), sep = "\n")
          EFA <- lavaan::lavaan(model, data, ordered = categorical, estimator = estimator, rotation = rotation, auto.var = TRUE, auto.efa = TRUE, int.ov.free = TRUE, mimic = mimic, control = list(iter.max = max.iter))
          if(!lavaan::lavInspect(EFA, what = "converged")){
            warning("The EFA model with modifications has not converged. The results from the original EFA (without modifications) are reported.")
            EFA <- EFA.back
          }
          MI <- lavaan::modindices(EFA, standardized = TRUE, power = TRUE, sort. = TRUE)
          phi <- as.matrix(as.data.frame(lavaan::inspect(EFA, what = "std")$psi))
          namesF <- colnames(phi)
          check.MI <- MI[MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF,]
          rm.MI <- apply(check.MI, 1, function(mi) phi[mi["lhs"], mi["rhs"]] != 0)
          if(length(which(MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF)[rm.MI]) > 0){
            MI <- MI[-which(MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF)[rm.MI],]
          }
        } else {
          while(nrow(do.MI) > 0){
            mods <- rbind(mods, do.MI[1,])
            model <- paste(model, paste(mods[nrow(mods), 1:3], collapse = " "), sep = "\n")
            EFA <- lavaan::lavaan(model, data, ordered = categorical, estimator = estimator, rotation = rotation, auto.var = TRUE, auto.efa = TRUE, int.ov.free = TRUE, mimic = mimic, control = list(iter.max = max.iter))
            if(!lavaan::lavInspect(EFA, what = "converged")){
              warning("The EFA model has not converged with the last sequential model modification. The results from the EFA without the last sequential model modification are reported.")
              EFA <- EFA.back
              MI <- lavaan::modindices(EFA, standardized = TRUE, power = TRUE, sort. = TRUE)
              break
            }
            EFA.back <- EFA
            MI <- lavaan::modindices(EFA, standardized = TRUE, power = TRUE, sort. = TRUE)
            phi <- as.matrix(as.data.frame(lavaan::inspect(EFA, what = "std")$psi))
            namesF <- colnames(phi)
            check.MI <- MI[MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF,]
            rm.MI <- apply(check.MI, 1, function(mi) phi[mi["lhs"], mi["rhs"]] != 0)
            if(length(which(MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF)[rm.MI]) > 0){
              MI <- MI[-which(MI$lhs %in% namesF & MI$op == "~~" & MI$rhs %in% namesF)[rm.MI],]
            }
            if(nrow(mods) == mod.args$max.mods){break}
            do.MI <- MI[MI$mi >= mod.args$MI.cut,]
            if(mod == "Saris"){
              tmp.do.MI <- do.MI[do.MI$op == "=~" & (abs(do.MI$sepc.all) >= mod.args$SEPC.lambda | do.MI$power < mod.args$MI.power),]
              tmp.do.MI <- rbind(tmp.do.MI, do.MI[do.MI$op == "~~" & (abs(do.MI$sepc.all) >= mod.args$SEPC.psi | do.MI$power < mod.args$MI.power),])
              do.MI <- tmp.do.MI
            }
            if(!mod.args$mod.error){do.MI <- do.MI[do.MI$op == "=~",]}
          }
        }
      }
    }

    # 2.3. Gather results
    fit <- lavaan::lavInspect(EFA, what = "fit")
    coef <- lavaan::inspect(EFA, what = "std")
    coef$lambda <- coef$lambda[colnames(data),]
    coef$theta <- coef$theta[colnames(data), colnames(data)]
    lambda <- as.matrix(as.data.frame(coef$lambda))
    phi <- as.matrix(as.data.frame(coef$psi))
    psi <- as.matrix(as.data.frame(coef$theta))
    coef.p <- lavaan::standardizedSolution(EFA)
    lambda.p <- matrix(NA, nrow = nrow(lambda), ncol = ncol(lambda), dimnames = list(rownames(lambda), colnames(lambda)))
    if(ncol(lambda) == 1){colnames(lambda) <- colnames(lambda.p) <- colnames(phi)}
    phi.p <- matrix(NA, nrow = nrow(phi), ncol = ncol(phi), dimnames = list(rownames(phi), colnames(phi)))
    psi.p <- matrix(NA, nrow = nrow(psi), ncol = ncol(psi), dimnames = list(rownames(psi), colnames(psi)))
    tmp.lambda.p <- coef.p[coef.p$op == "=~",]
    tmp.phi.p <- coef.p[coef.p$lhs %in% namesF & coef.p$rhs %in% namesF & coef.p$op == "~~",]
    tmp.psi.p <- coef.p[coef.p$lhs %in% rownames(lambda) & coef.p$rhs %in% rownames(lambda) & coef.p$op == "~~",]
    for(x in 1:nrow(tmp.lambda.p)){
      lambda.p[tmp.lambda.p$rhs[x], tmp.lambda.p$lhs[x]] <- round(tmp.lambda.p$pvalue[x], 5)
    }
    for(f in 1:nrow(tmp.phi.p)){
      phi.p[tmp.phi.p$rhs[f], tmp.phi.p$lhs[f]] <- round(tmp.phi.p$pvalue[f], 5)
      phi.p[tmp.phi.p$lhs[f], tmp.phi.p$rhs[f]] <- round(tmp.phi.p$pvalue[f], 5)
    }
    for(x in 1:nrow(tmp.psi.p)){
      psi.p[tmp.psi.p$rhs[x], tmp.psi.p$lhs[x]] <- round(tmp.psi.p$pvalue[x], 5)
      psi.p[tmp.psi.p$lhs[x], tmp.psi.p$rhs[x]] <- round(tmp.psi.p$pvalue[x], 5)
    }

  }

  #--------------
  # 3. mplus EFA
  #--------------

  if(software == "mplus"){

    if(!rotation %in% c("TARGET", "RETAM")){
      model.names <- gsub(";", "", model)
      model.names <- gsub("\n", "", model.names)
      model.names <- gsub(" \\(\\*1\\)", "", model.names)
      namesF <- strsplit(unique(sapply(strsplit(model.names, " BY "), function(x) x[1])), " ")[[1]]
      nF <- length(namesF)
      namesX <- strsplit(unique(sapply(strsplit(model.names, " BY "), function(x) x[2])), " ")[[1]]
      nX <- length(namesX)
    } else {
      model.names <- gsub(" \\(\\*1\\)", "", model)
      model.names <- gsub("~0", "", model.names)
      model.names <- strsplit(model.names, ";\n")[[1]]
      model.names <- gsub(";", "", model.names)
      model.names <- gsub("\n", " ", model.names)
      namesF <- sapply(strsplit(model.names, " BY "), function(x) x[1])
      nF <- length(namesF)
      namesX <- unique(unlist(strsplit(sapply(strsplit(model.names, " BY "), function(x) x[2]), "  ")))
      namesX <- unique(unlist(strsplit(namesX, " ")))
      nX <- length(namesX)
    }

    if(rotation != "RETAM"){

      # 3.1. Fit EFA model and compute MI
      if(!is.null(categorical)){
        mplus.VARIABLE <- paste0("CATEGORICAL = ", paste(categorical, collapse = " "), ";")
        if(nchar(mplus.VARIABLE) >= 90){
          cut <- 1
          tmp <- c()
          for(s in 1:(ceiling((nchar(mplus.VARIABLE) + 1) / 90))){
            pos <- which.min(abs(gregexpr(" ", mplus.VARIABLE)[[1]] - round(nchar(mplus.VARIABLE) / ceiling((nchar(mplus.VARIABLE) + 1) / 90)) * s))
            cut <- c(cut, gregexpr(" ", mplus.VARIABLE)[[1]][pos])
            if(s == 1){
              tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s], cut[s + 1] - 1), "\n"))
            } else if(s > 1 & s < ceiling((nchar(mplus.VARIABLE) + 1) / 90)) {
              tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s] + 1, cut[s + 1] - 1), "\n"))
            } else {
              tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s] + 1, nchar(mplus.VARIABLE))))
            }
          }
          mplus.VARIABLE <- paste(tmp, collapse = "")
        }
      } else {
        mplus.VARIABLE <- NULL
      }
      mplus.ANALYSIS <- paste0("ESTIMATOR = ", estimator, "; ROTATION = ", rotation, "; ITERATIONS = ", max.iter, ";")
      mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = model, ANALYSIS = mplus.ANALYSIS, OUTPUT = "SAMPSTAT; STANDARDIZED; MODINDICES(ALL 0)")
      if(suppressMessages){
        EFA <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
      } else {
        EFA <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
      }
      if(length(EFA$results$warnings) > 0){print(EFA$results$warnings)}
      if(length(EFA$results$errors) > 0){print(EFA$results$errors); stop("Mplus had convergence problems.")}
      MI <- EFA$results$mod_indices
      if(length(-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF)) > 0){
        MI <- MI[-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF),]
      }
      if(!is.null(MI)){MI <- MI[order(MI$MI, decreasing = TRUE),]}
      MI <- MI[MI$operator == "WITH" & MI$MI != 999,]

      # 3.2. Introduce modifications if required
      if(mod == "MI"){
        do.MI <- MI[MI$MI >= mod.args$MI.cut,]
        if(!mod.args$mod.error){do.MI <- do.MI[do.MI$operator == "BY",]}
        if(nrow(do.MI > 0)){
          if(!mod.args$stepwise){
            mods <- do.MI
            model <- paste0(paste(model, paste(apply(mods[,1:3], 1, paste, collapse = " "), collapse = ";\n"), sep = "\n"), ";")
            mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = model, ANALYSIS = mplus.ANALYSIS, OUTPUT = "SAMPSTAT; STANDARDIZED; MODINDICES(ALL 0)")
            if(suppressMessages){
              EFA <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
            } else {
              EFA <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
            }
            if(length(EFA$results$warnings) > 0){print(EFA$results$warnings)}
            if(length(EFA$results$errors) > 0){print(EFA$results$errors)}
            MI <- EFA$results$mod_indices
            if(length(-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF)) > 0){
              MI <- MI[-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF),]
            }
            if(!is.null(MI)){MI <- MI[order(MI$MI, decreasing = TRUE),]}
            MI <- MI[MI$operator == "WITH" & MI$MI != 999,]
          } else {
            while(nrow(do.MI) > 0){
              mods <- rbind(mods, do.MI[1,])
              model <- paste0(paste(model, paste(apply(mods[nrow(mods), 1:3], 1, paste, collapse = " "), collapse = ";\n"), sep = "\n"), ";")
              mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = model, ANALYSIS = mplus.ANALYSIS, OUTPUT = "SAMPSTAT; STANDARDIZED; MODINDICES(ALL 0)")
              if(suppressMessages){
                EFA <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
              } else {
                EFA <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
              }
              if(length(EFA$results$warnings) > 0){print(EFA$results$warnings)}
              if(length(EFA$results$errors) > 0){print(EFA$results$errors); break}
              MI <- EFA$results$mod_indices
              if(length(-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF)) > 0){
                MI <- MI[-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF),]
              }
              if(!is.null(MI)){MI <- MI[order(MI$MI, decreasing = TRUE),]}
              MI <- MI[MI$operator == "WITH" & MI$MI != 999,]
              if(nrow(mods) == mod.args$max.mods){break}
              do.MI <- MI[MI$MI >= mod.args$MI.cut,]
              if(!mod.args$mod.error){do.MI <- do.MI[do.MI$operator == "BY",]}
            }
          }
        }
      }

    } else if (rotation == "RETAM"){

      # 3.1. Fit EFA model
      if(!is.null(categorical)){
        mplus.VARIABLE <- paste0("CATEGORICAL = ", paste(categorical, collapse = " "), ";")
        if(nchar(mplus.VARIABLE) >= 90){
          cut <- 1
          tmp <- c()
          for(s in 1:(ceiling((nchar(mplus.VARIABLE) + 1) / 90))){
            pos <- which.min(abs(gregexpr(" ", mplus.VARIABLE)[[1]] - round(nchar(mplus.VARIABLE) / ceiling((nchar(mplus.VARIABLE) + 1) / 90)) * s))
            cut <- c(cut, gregexpr(" ", mplus.VARIABLE)[[1]][pos])
            if(s == 1){
              tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s], cut[s + 1] - 1), "\n"))
            } else if(s > 1 & s < ceiling((nchar(mplus.VARIABLE) + 1) / 90)) {
              tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s] + 1, cut[s + 1] - 1), "\n"))
            } else {
              tmp <- c(tmp, paste0(substr(mplus.VARIABLE, cut[s] + 1, nchar(mplus.VARIABLE))))
            }
          }
          mplus.VARIABLE <- paste(tmp, collapse = "")
        }
      } else {
        mplus.VARIABLE <- NULL
      }
      mplus.ANALYSIS <- paste0("ESTIMATOR = ", estimator, "; ROTATION = TARGET; ITERATIONS = ", max.iter, ";")
      mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = model, ANALYSIS = mplus.ANALYSIS, OUTPUT = "SAMPSTAT; STANDARDIZED; MODINDICES(ALL 0)")
      if(suppressMessages){
        EFA <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
      } else {
        EFA <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
      }
      if(length(EFA$results$warnings) > 0){print(EFA$results$warnings)}
      if(length(EFA$results$errors) > 0){stop("Mplus had convergence problems.")}

      # 3.2. Introduce modifications
      coef <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "parameters", quiet = TRUE)$parameters$stdyx.standardized
      lambda <- coef_lambda(coef, namesX, namesF)
      H <- list()
      H0 <- H[[1]] <- refine.H(lambda)
      model <- modFA(lambda = H0, software = "mplus")$EFAt
      mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = model, ANALYSIS = mplus.ANALYSIS, OUTPUT = "SAMPSTAT; STANDARDIZED; MODINDICES(ALL 0)")
      if(suppressMessages){
        EFA <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
      } else {
        EFA <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
      }
      if(length(EFA$results$warnings) > 0){print(EFA$results$warnings)}
      if(length(EFA$results$errors) > 0){print(EFA$results$errors); stop("Mplus had convergence problems.")}
      coef <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "parameters", quiet = TRUE)$parameters$stdyx.standardized
      lambda <- coef_lambda(coef, namesX, namesF)
      H1 <- H[[2]] <- refine.H(lambda)
      i <- 1
      keep.going <- any(H0 != H1)
      while(keep.going){
        i <- i + 1
        H0 <- H1
        model <- modFA(lambda = H0, software = "mplus")$EFAt
        mplus.Obj <- MplusAutomation::mplusObject(rdata = data, VARIABLE = mplus.VARIABLE, MODEL = model, ANALYSIS = mplus.ANALYSIS, OUTPUT = "SAMPSTAT; STANDARDIZED; MODINDICES(ALL 0)")
        if(suppressMessages){
          EFA <- suppressMessages(MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE))
        } else {
          EFA <- MplusAutomation::mplusModeler(mplus.Obj, dataout = paste0(mplus.path, ".dat"), writeData = "always", run = 1, hashfilename = FALSE)
        }
        if(length(EFA$results$warnings) > 0){print(EFA$results$warnings)}
        if(length(EFA$results$errors) > 0){print(EFA$results$errors); stop("Mplus had convergence problems.")}
        coef <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "parameters", quiet = TRUE)$parameters$stdyx.standardized
        lambda <- coef_lambda(coef, namesX, namesF)
        H1 <- refine.H(lambda)
        H[[i + 1]] <- H1
        if(i == mod.args$max.mods - 1){break}
        kg <- c()
        for(h in 1:(length(H) - 1)){kg <- c(kg, any(H[[h]] != H1))}
        keep.going <- all(kg)
      }
      MI <- EFA$results$mod_indices
      if(length(-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF)) > 0){
        MI <- MI[-which(MI[,1] %in% namesX & MI$operator == "WITH" & MI[,3] %in% namesF),]
      }
      MI <- MI[MI$operator == "WITH" & MI$MI != 999,]
      if(!is.null(MI)){MI <- MI[order(MI$MI, decreasing = TRUE),]}

    }

    # 3.3. Gather results
    fit <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "summaries", quiet = TRUE)$summaries
    coef <- MplusAutomation::readModels(paste0(mplus.path, ".out"), what = "parameters", quiet = TRUE)$parameters$stdyx.standardized
    if(is.null(coef)){print(EFA$results$errors); stop("Mplus had convergence problems.")}
    lambda <- matrix(0, nrow = nX, ncol = nF, dimnames = list(namesX, namesF))
    lambda.p <- matrix(NA, nrow = nX, ncol = nF, dimnames = list(namesX, namesF))
    phi <- matrix(0, nrow = nF, ncol = nF, dimnames = list(namesF, namesF))
    phi.p <- matrix(NA, nrow = nF, ncol = nF, dimnames = list(namesF, namesF))
    psi <- matrix(0, nrow = nX, ncol = nX, dimnames = list(namesX, namesX))
    psi.p <- matrix(NA, nrow = nX, ncol = nX, dimnames = list(namesX, namesX))
    tmp.lambda <- coef[grepl(".BY", coef$paramHeader),]
    tmp.lambda$paramHeader <- sapply(tmp.lambda$paramHeader, function(x) strsplit(x, "\\.")[[1]][1])
    tmp.phi <- coef[grepl(".WITH", coef$paramHeader) & coef$param %in% namesF,]
    tmp.phi$paramHeader <- sapply(tmp.phi$paramHeader, function(x) strsplit(x, "\\.")[[1]][1])
    tmp.phi <- tmp.phi[tmp.phi$paramHeader %in% namesF,]
    tmp.phi <- rbind(tmp.phi, coef[coef$paramHeader == "Variances",])
    tmp.psi <- coef[grepl(".WITH", coef$paramHeader) & coef$param %in% namesX,]
    tmp.psi$paramHeader <- sapply(tmp.psi$paramHeader, function(x) strsplit(x, "\\.")[[1]][1])
    tmp.psi <- tmp.psi[tmp.psi$paramHeader %in% namesX,]
    tmp.psi <- rbind(tmp.psi, coef[coef$paramHeader == "Residual.Variances",])
    for(x in 1:nrow(tmp.lambda)){
      lambda[tmp.lambda$param[x], tmp.lambda$paramHeader[x]] <- tmp.lambda$est[x]
      lambda.p[tmp.lambda$param[x], tmp.lambda$paramHeader[x]] <- tmp.lambda$pval[x]
    }
    for(f in 1:nrow(tmp.phi)){
      if(tmp.phi$paramHeader[f] != "Variances"){
        phi[tmp.phi$param[f], tmp.phi$paramHeader[f]] <- round(tmp.phi$est[f], 5)
        phi[tmp.phi$paramHeader[f], tmp.phi$param[f]] <- round(tmp.phi$est[f], 5)
        phi.p[tmp.phi$param[f], tmp.phi$paramHeader[f]] <- round(tmp.phi$pval[f], 5)
        phi.p[tmp.phi$paramHeader[f], tmp.phi$param[f]] <- round(tmp.phi$pval[f], 5)
      } else {
        phi[tmp.phi$param[f], tmp.phi$param[f]] <- round(tmp.phi$est[f], 5)
        phi.p[tmp.phi$param[f], tmp.phi$param[f]] <- NA
      }
    }
    if(nrow(tmp.psi) > 0){
      for(x in 1:nrow(tmp.psi)){
        if(tmp.psi$paramHeader[x] != "Residual.Variances"){
          psi[tmp.psi$param[x], tmp.psi$paramHeader[x]] <- round(tmp.psi$est[x], 5)
          psi[tmp.psi$paramHeader[x], tmp.psi$param[x]] <- round(tmp.psi$est[x], 5)
          psi.p[tmp.psi$param[x], tmp.psi$paramHeader[x]] <- round(tmp.psi$pval[x], 5)
          psi.p[tmp.psi$paramHeader[x], tmp.psi$param[x]] <- round(tmp.psi$pval[x], 5)
        } else {
          psi[tmp.psi$param[x], tmp.psi$param[x]] <- round(tmp.psi$est[x], 5)
          psi.p[tmp.psi$param[x], tmp.psi$param[x]] <- NA
        }
      }
    }

  }

  if(all(psi == 0)){
    hj <- diag((lambda %*% phi) %*% solve(phi) %*% t(lambda %*% phi))
    diag(psi) <- 1 - hj
  }

  if(software == "lavaan"){
    fit <- round(c(npar = as.numeric(fit["npar"]), ChiSq = as.numeric(fit["chisq"]), ChiSq_df = as.numeric(fit["df"]),
                   ChiSq_p = as.numeric(fit["pvalue"]), CFI = as.numeric(fit["cfi"]), TLI = as.numeric(fit["tli"]),
                   RMSEA = as.numeric(fit["rmsea"]), RMSEA_low = as.numeric(fit["rmsea.ci.lower"]), RMSEA_up = as.numeric(fit["rmsea.ci.upper"]),
                   RMSEA_p = as.numeric(fit["rmsea.pvalue"]), SRMR = as.numeric(fit["srmr"]), AIC = as.numeric(fit["aic"]), BIC = as.numeric(fit["bic"])), 3)
  } else if(software == "mplus"){
    if(is.null(categorical)){
      fit <- round(c(npar = as.numeric(fit["Parameters"]), ChiSq = as.numeric(fit["ChiSqM_Value"]), ChiSq_df = as.numeric(fit["ChiSqM_DF"]),
                     ChiSq_p = as.numeric(fit["ChiSqM_PValue"]), CFI = as.numeric(fit["CFI"]), TLI = as.numeric(fit["TLI"]),
                     RMSEA = as.numeric(fit["RMSEA_Estimate"]), RMSEA_low = as.numeric(fit["RMSEA_90CI_LB"]), RMSEA_up = as.numeric(fit["RMSEA_90CI_UB"]),
                     RMSEA_p = as.numeric(fit["RMSEA_pLT05"]), SRMR = as.numeric(fit["SRMR"]), AIC = as.numeric(fit["AIC"]), BIC = as.numeric(fit["BIC"])), 3)
    } else {
      fit <- round(c(npar = as.numeric(fit["Parameters"]), ChiSq = as.numeric(fit["ChiSqM_Value"]), ChiSq_df = as.numeric(fit["ChiSqM_DF"]),
                     ChiSq_p = as.numeric(fit["ChiSqM_PValue"]), CFI = as.numeric(fit["CFI"]), TLI = as.numeric(fit["TLI"]),
                     RMSEA = as.numeric(fit["RMSEA_Estimate"]), RMSEA_low = as.numeric(fit["RMSEA_90CI_LB"]), RMSEA_up = as.numeric(fit["RMSEA_90CI_UB"]),
                     RMSEA_p = as.numeric(fit["RMSEA_pLT05"])), 3)
    }
  }

  #-------------------
  # 4. Export results
  #-------------------

  if(rm.files & software == "mplus"){file.remove(paste0(mplus.path, c(".dat", ".inp", ".out")))}
  specifications <- list(type = "EFA", model = model, data = data, n.factors = n.factors, categorical = categorical, estimator = estimator, rotation = rotation, software = software, mimic.mplus = mimic.mplus, mplus.path = mplus.path, rm.files = rm.files, max.iter = max.iter, mod = mod, mod.args = mod.args)
  res <- list(model.fit = fit, lambda = lambda, phi = phi, psi = psi, lambda.p = lambda.p, phi.p = phi.p, psi.p = psi.p, MI = MI, mods = mods, out = EFA, specifications = specifications)
  class(res) <- "wrapFA"
  return(res)

}
